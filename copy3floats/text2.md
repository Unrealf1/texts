# Как скопировать 3 флота?

## Предыстория (коротко)

Под асаном стабильно падал сервер. Виной тому был вот такой кусок кода:

```cpp
get_points_around(center, [](auto& points){
   for (auto& point : points) {
       // some logic involving the point
       auto distSq = distance_sq3(point, center); // <- crash here
       if (distSq < someConstant) { /* do more stuff */ }
       // more logic  
   }
});
```

Извилистый путь дебага вывел меня к корню проблемы: `distance_sq3` принимает `Point4`, а `points` это массив `Point3`, причём имплисит каст `Point3` к `Point4` выглядит приблизительно так:

```cpp
operator Point4() const { return load_128_bit_as_4_floats(&x); }
```

А значит, на последнем (и только на последнем!) элементе `points` мы прочитаем один лишний `float`, за что и получим краш. Во имя оптимизации, конечно же! 

Решается проблема просто: добавлением фиктивного элемента в конец массива. Но вся эта ситуация какая-то _неправильная_, тут нужно разобраться до конца.

## Зачем вообще так делать?

Казалось бы, в чём вообще тут оптимизация? Мы читаем на один флоат больше, чем нужно, да ещё и читаем не свою память в процессе.

Дело в том, что процессор может читать и писать оперативную память кусками определённого размера. Например, куском в 64 бита или 128 бит. Один флоат занимает 4 байта или 32 бита, а значит, 3 флота займут 96 бит. Это больше 64 бит, но меньше 128, а загрузить ровно 96 бит (судя по всему) на большинстве x86 процессоров нельзя. Тогда остаётся два варианта: прочитать память несколько раз или прочитать лишнюю память. Работа с памятью __гораздо__ медленнее работы с регистрами процессора, так что логика в том, чтобы уменьшить количество чтений, определённо есть.

Проверить, приносит ли пользу какая-то странная оптимизация, можно одним способом: замерить!

## Замеры

Я создал шаблон функции, который занимается копированием 499 `Point3` в массив из `Point4`:

```cpp
struct Point4 {
    float x,y,z,u;
};

template<typename T>
using holder = std::array<T, 500>;

template<typename P3>
void busy_code(const holder<P3>& in, holder<Point4>& out) {
    // copy one less element to prevent buffer overflow
    std::copy(in.begin(), in.end() - 1, out.begin());
}
```

И несколько вариаций `Point3` для сравнения:

```cpp
// Самая простая, надёжная, очевидная и точно корректная реализация
struct Point3_default{
    float x, y, z;
    operator Point4() const {
        Point4 res;
        res.x = x;
        res.y = y;
        res.z = z;
        return res;
    };
};

// Попросим стдлибу оптимально скопировать 3 бита
struct Point3_copy3{
    float x, y, z;
    operator Point4() const {
        Point4 res;
        std::copy((float*)this, ((float*)this) + 3, (float*)&res);
        return res;
    };
};

// Попросим стдлибу оптимально скопировать 4 бита
struct Point3_copy4{
    float x, y, z;
    operator Point4() const {
        Point4 res;
        std::copy((float*)this, ((float*)this) + 4, (float*)&res);
        return res;
    };
};

// Напрямую указать компилятору использовать инструкции для работы с 128 битами
struct Point3_simd{
    float x, y, z;
    operator Point4() const {
        Point4 res;
        auto rptr = reinterpret_cast<float*>(&res);
        auto tptr = reinterpret_cast<const float*>(this);
        auto data = _mm_loadu_ps(tptr); // работает только на x86, no ARM allowed :(
        _mm_storeu_ps(rptr, data);
        return res;
    }
};
```

На своём ноутбуке со слабеньким AMD 3020e и 3200 MHz DDR4 я получил такой результат, используя gcc 13.2.1: 

#### Оптимизация `-O3`:

| relative spd | ns/op    | op/s         | ins/op   | cyc/op    | Point3 type |
| ------------:| --------:| ------------:| --------:| ---------:|:----------- |
| 100.0%       | 585.65   | 1,707,513.66 | 3,856.00 | 1,497.21  | `default`   |
| 272.8%       | 214.65   | 4,658,825.10 | 2,997.00 | 548.23    | `simd`      |
| 13.0%        | 4,502.69 | 222,089.42   | 4,993.00 | 11,477.74 | `copy3`     |
| 268.2%       | 218.35   | 4,579,883.17 | 2,997.00 | 558.09    | `copy4`     |

#### Оптимизация `-O2`:

| relative spd | ns/op    | op/s         | ins/op   | cyc/op    | Point3 type |
| ------------:| --------:| ------------:| --------:| ---------:|:----------- |
| 100.0%       | 589.69   | 1,695,811.78 | 4,993.00 | 1,514.14  | `default`   |
| 274.0%       | 215.18   | 4,647,261.40 | 2,997.00 | 552.89    | `simd`      |
| 13.2%        | 4,465.41 | 223,943.42   | 4,993.00 | 11,477.08 | `copy3`     |
| 273.2%       | 215.82   | 4,633,566.07 | 2,997.00 | 553.58    | `copy4`     |

То есть `simd` и `copy4` версии практически не отличаются и делят первое место, затем идёт обычная версия, а затем (что меня удивило) с огромным отрывом `copy3`.

## Разбор полётов

Посмотрим на ассемблер, сгенерированный компилятором. Смотреть будем на `-O2` версию, потому что для всех, кроме `default` версии, разницы никакой, а `-O3` версию `default` читать на порядок сложнее с едва различимой разницей в производительности.

Пара слов про ассемблер:

* `rax`, `rdi`, `xmm0` и похожие -- это регистры. Можно воспринимать как вшитые в процессор переменные, тип которых может в любой момент времени быть хоть флотом, хоть интом, хоть указателем

* Запись вида `[rax + 5]` означает _разыменовывание_ указателя со значением `rax + 5`

* В регистр `rdi` кладётся первый аргумент функции, `const holder<Point3>& in` в нашем случае

* В регистр `rsi` кладётся второй аргумент функции, `holder<Point4>& out` в нашем случае

Начнём с базы: `Point3_default` 

```cpp
operator Point4() const {
    Point4 res;
    res.x = x;
    res.y = y;
    res.z = z;
    return res;
};
```

```nasm
void busy_code<Point3_default>
    // Сохраняем адрес &in + 499 * sizeof(Point3) в rax. 
    // Это указатель на конец копируемого массива
    lea     rax, [rdi+5988]
.L6:
    // rdi указывает на текущий элемент in, rsi -- на текущий элемент out
    movss   xmm2, DWORD PTR [rdi+4] // Читаем .y текущей точки в xmm2
    movss   xmm0, DWORD PTR [rdi] // Читаем .x текущей точки в xmm0
    add     rdi, 12 // Двигаем rdi вперёд на один sizeof(Point3)
    add     rsi, 16 // Двигаем rsi вперёд на один sizeof(Point4)
    movss   xmm1, DWORD PTR [rdi-4] // Читаем .z текущей точки в xmm1
    unpcklps        xmm0, xmm2 // Битовая магия, но теперь в xmm0 лежат .x и .y
    movlhps xmm0, xmm1 // Всё ещё битовая магия, но теперь x,y,z лежат в xmm0
    movups  XMMWORD PTR [rsi-16], xmm0 // Сохраняем Point4 в out
    cmp     rdi, rax // Если не дошли до конца in, прыгаем в .L6
    jne     .L6
    ret
```

Для каждой точки мы честно читаем `.x`, `.y`, `.z` из памяти, а затем пишем их (и неопределённый мусор в `.u`) одновременно в нужное место.

Теперь рассмотрим самые быстрые варианты и сравним их с базовым.

`Point3_simd`:

```cpp
operator Point4() const {
    Point4 res;
    auto rptr = reinterpret_cast<float*>(&res);
    auto tptr = reinterpret_cast<const float*>(this);
    auto data = _mm_loadu_ps(tptr);
    _mm_storeu_ps(rptr, data);
    return res;
}
```

```nasm
void busy_code<Point3_simd>
    // Сохраняем адрес &in + 499 * sizeof(Point3) в rax. 
    // Это указатель на конец копируемого массива
    lea     rax, [rdi+5988]
.L2:
    // rdi указывает на текущий элемент in, rsi -- на текущий элемент out

    // Читаем сразу 4 флота, начиная с адреса rdi, и сохраняем в xmm0
    movups  xmm0, XMMWORD PTR [rdi] 
    add     rdi, 12 // Двигаем rdi вперёд на один sizeof(Point3)
    add     rsi, 16 // Двигаем rsi вперёд на один sizeof(Point4)
    movups  XMMWORD PTR [rsi-16], xmm0 // Сохраняем один Point4 в out
    cmp     rdi, rax // Если не дошли до конца in, прыгаем в .L2
    jne     .L2
    ret
```

Внутри цикла код гораздо короче и проще: одно чтение, одна запись, сдвиг указателей. Ничего лишнего, простота и эффективность.

`Point3_copy4` практически не отличается от этой версии, единственная разница: вместо первого `movups`, компилятор по какой-то неясной для меня причине использует инструкцию `movdqu`, которая создана для работы с интами, а не флотами. Соответственно, и производительность этих версий тоже очень похожа.

И интересное напоследок: почему же так медленно работает версия, копирующая 3 флота через `std::copy`?

```cpp
operator Point4() const {
    Point4 res;
    std::copy((float*)this, ((float*)this) + 3, (float*)&res);
    return res;
};
```

```nasm
void busy_code<Point3_copy3>
    // Сохраняем адрес &in + 499 * sizeof(Point3) в rdx    
    lea     rdx, [rdi+5988] 
.L12:
    mov     rax, QWORD PTR [rdi] // Копируем .x и .y в rax
    add     rdi, 12 // rdi += sizeof(Point3)
    add     rsi, 16 // rsi += sizeof(Point4)
    // Тут и ниже rsp-24 -- это адрес для Point4, который лежит на стеке
    mov     QWORD PTR [rsp-24], rax // Записываем .x, .y в новый Point4
    mov     eax, DWORD PTR [rdi-4] // Записываем .z в eax
    mov     DWORD PTR [rsp-16], eax // Записываем .z в новый Point4
    movaps  xmm0, XMMWORD PTR [rsp-24] // Записываем новый Point4 в xmm0
    movups  XMMWORD PTR [rsi-16], xmm0 // Записываем Point4 в out
    cmp     rdx, rdi // Если не дошли до конца in, прыгаем в .L12
    jne     .L12
    ret
```

То есть этот код по-честному записал память сначала на стек, а уже потом скопировал её со стека в массив `out`. Видимо, компилятор не смог применить RVO в этом случае, хотя смог применить его для `copy4`. 

И небольшая сводная таблица в конце об устройстве тела цикла:

| relative spd | memory reads | memory writes | instructions | Point3 type |
| ------------ | ------------ | ------------- | ------------ | ----------- |
| 100.0%       | 3            | 1             | 10           | `default`   |
| 274.0%       | 1            | 1             | 6            | `simd`      |
| 13.2%        | 3            | 3             | 10           | `copy3`     |
| 273.2%       | 1            | 1             | 6            | `copy4`     |

## Вывод

Как бы это ни было печально, судя по всему, копировать 3 флота гораздо эффективнее, копируя 4 флота и читая не свою память
